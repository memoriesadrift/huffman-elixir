defmodule Huffman.Encoder do
  alias Huffman.Tree, as: Tree
  # TODO: Add moduledoc

  @spec encode_text(String.t, map) :: String.t
  def encode_text(text, encoding) do
    text
    |> String.graphemes()
    |> Enum.map(&(Map.get(encoding, &1)))
    |> Enum.join()
  end

  @spec generate_encoding(map) :: map
  @doc """
  Generates a Huffman Encoding given a frequency map, such as one produced by `Enum.frequencies/1`
  ### Examples
  ```
  iex> Huffman.Encoder.generate_encoding(%{"c" => 1, "o" => 1, "s" => 1, "y" => 1})
  %{"c" => "10", "o" => "11", "s" => "00", "y" => "01"}
  ```
  """
  def generate_encoding(frequency_map) do
    frequency_map
    |> leaf_nodes_from_frequencies()
    |> Enum.sort_by(&(&1.value.freq))
    |> generate_huffman_tree()
    |> find_character_mappings()
  end

  @spec find_character_mappings(Tree.tree, bitstring) :: map
  @doc """
  Finds the character encodings given a valid Huffman tree, such as one generated by `generate_huffman_tree/1`.
  The second, optional argument specifies a base code to be added **to the end** of every encoded character.
  ### Examples
  ```
  iex> %{
  children: [
    %{
      children: [
        %{children: [], value: %{freq: 1, symbols: "s"}},
        %{children: [], value: %{freq: 1, symbols: "y"}}
      ],
      value: %{freq: 2, symbols: "sy"}
    },
    %{
      children: [
        %{children: [], value: %{freq: 1, symbols: "c"}},
        %{children: [], value: %{freq: 1, symbols: "o"}}
      ],
      value: %{freq: 2, symbols: "co"}
    }
  ],
  value: %{freq: 4, symbols: "syco"}
  } |> Huffman.Encoder.find_character_mapping()
  %{"c" => "10", "o" => "11", "s" => "00", "y" => "01"}
  ```

  """
  def find_character_mappings(tree, code \\ "")
  def find_character_mappings(tree, code) when length(tree.children) === 0 do
    %{tree.value.symbols => code}
  end
  def find_character_mappings(tree, code) when length(tree.children) > 0 do
    tree.children
    |> Enum.with_index()
    |> Enum.flat_map(fn {child, idx} ->
      find_character_mappings(child, code <> Integer.to_string(idx))
    end)
    |> Map.new()
  end

  @spec generate_huffman_tree([Tree.tree]) :: Tree.tree
  @doc """
  Generates a Huffman Tree given a list of leaf nodes, sorted by frequency.
  To get leaf nodes from frequencies given by `Enum.frequencies/1` use `leaf_nodes_from_frequencies/1` (private).

  ### Algorithm Details
  [Taken from Wikipedia.](https://en.wikipedia.org/wiki/Huffman_coding#Basic_technique)
  Create a leaf node for each symbol and add it to the priority queue.
  While there is more than one node in the queue:
      Remove the two nodes of highest priority (lowest probability) from the queue
      Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
      Add the new node to the queue.
  The remaining node is the root node and the tree is complete.
  """
  def generate_huffman_tree([h | t]) when length(t) == 0, do: h
  def generate_huffman_tree([h | t]) when length(t) > 0 do
    [h2 | rest] = t
    joined = Tree.join(h, h2, fn v1, v2 ->
      %{symbols: v1.symbols <> v2.symbols, freq:  v1.freq + v2.freq}
    end)

    [joined | rest]
    |> Enum.sort_by(&(&1.value.freq))
    |> generate_huffman_tree()
  end

  @spec leaf_nodes_from_frequencies(map) :: [Tree.tree]
  @doc """
  Generates a list of tree nodes (leaf nodes) for a given frequency.
  """
  def leaf_nodes_from_frequencies(frequency_map) do
   frequency_map
   |> Enum.map(&(&1))
   |> Enum.map(fn {k, v} -> Tree.new(%{symbols: k, freq: v})end)
  end
end
