defmodule Huffman.Encoder do
  alias Huffman.Tree, as: Tree

  @moduledoc """
  Contains encoding related functionality.
  """

  @doc """
  Encodes a text given an encoding,
  """
  @spec encode_text(String.t(), map) :: String.t()
  def encode_text(text, encoding) do
    text
    |> String.graphemes()
    |> Enum.map(&Map.get(encoding, &1))
    |> Enum.join()
  end

  @doc """
  Generates a Huffman Encoding given a frequency map, such as one produced by `Enum.frequencies/1`
  ### Examples
  ```
  iex> Huffman.Encoder.generate_encoding(%{"c" => 1, "o" => 1, "s" => 1, "y" => 1})
  %{"c" => "10", "o" => "11", "s" => "00", "y" => "01"}
  ```
  """
  @spec generate_encoding(map) :: map
  def generate_encoding(frequency_map) do
    frequency_map
    |> leaf_nodes_from_frequencies()
    |> Enum.sort_by(& &1.value.freq)
    |> generate_huffman_tree()
    |> find_character_mappings()
  end

  @doc """
  Finds the character encodings given a valid Huffman tree, such as one generated by `generate_huffman_tree/1`.
  The second, optional argument specifies a base code to be added **to the end** of every encoded character.
  ### Examples
  ```
  iex> %{
  children: [
    %{
      children: [
        %{children: [], value: %{freq: 1, symbols: "s"}},
        %{children: [], value: %{freq: 1, symbols: "y"}}
      ],
      value: %{freq: 2, symbols: "sy"}
    },
    %{
      children: [
        %{children: [], value: %{freq: 1, symbols: "c"}},
        %{children: [], value: %{freq: 1, symbols: "o"}}
      ],
      value: %{freq: 2, symbols: "co"}
    }
  ],
  value: %{freq: 4, symbols: "syco"}
  } |> Huffman.Encoder.find_character_mapping()
  %{"c" => "10", "o" => "11", "s" => "00", "y" => "01"}
  ```
  """
  @spec find_character_mappings(Tree.tree(), bitstring) :: map
  def find_character_mappings(tree, code \\ "")

  def find_character_mappings(tree, code) when length(tree.children) === 0 do
    %{tree.value.symbols => code}
  end

  def find_character_mappings(tree, code) when length(tree.children) > 0 do
    tree.children
    |> Enum.with_index()
    |> Enum.flat_map(fn {child, idx} ->
      find_character_mappings(child, code <> Integer.to_string(idx))
    end)
    |> Map.new()
  end

  @doc """
  Generates a Huffman Tree given a list of leaf nodes, sorted by frequency.
  To get leaf nodes from frequencies given by `Enum.frequencies/1` use `leaf_nodes_from_frequencies/1`.

  ### Algorithm Details
  [Taken from Wikipedia.](https://en.wikipedia.org/wiki/Huffman_coding#Basic_technique)
  Create a leaf node for each symbol and add it to the priority queue.
  While there is more than one node in the queue:
      Remove the two nodes of highest priority (lowest probability) from the queue
      Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
      Add the new node to the queue.
  The remaining node is the root node and the tree is complete.

  ### Examples
  ```
  iex> Huffman.Encoder.leaf_nodes_from_frequencies(%{"E" => 1, "S" => 1, "T" => 2}) |> Enum.sort_by(& &1.value.freq) |> Huffman.Encoder.generate_huffman_tree
  %{
    children: [
      %{
        children: [
          %{children: [], value: %{freq: 1, symbols: "E"}},
          %{children: [], value: %{freq: 1, symbols: "S"}}
        ],
        value: %{freq: 2, symbols: "ES"}
      },
      %{children: [], value: %{freq: 2, symbols: "T"}}
    ],
    value: %{freq: 4, symbols: "EST"}
  }
  ```
  """
  @spec generate_huffman_tree([Tree.tree()]) :: Tree.tree()
  def generate_huffman_tree([h | t]) when length(t) == 0, do: h

  def generate_huffman_tree([h | t]) when length(t) > 0 do
    [h2 | rest] = t

    joined =
      Tree.join(h, h2, fn v1, v2 ->
        %{symbols: v1.symbols <> v2.symbols, freq: v1.freq + v2.freq}
      end)

    [joined | rest]
    |> Enum.sort_by(& &1.value.freq)
    |> generate_huffman_tree()
  end

  @doc """
  Generates a list of trees (leaf nodes) for a given frequency distribution.
  ### Examples
  ```
  iex> Huffman.Encoder.leaf_nodes_from_frequencies(%{"E" => 1, "S" => 1, "T" => 2})                          [
  [
   %{children: [], value: %{freq: 1, symbols: "E"}},
   %{children: [], value: %{freq: 1, symbols: "S"}},
   %{children: [], value: %{freq: 2, symbols: "T"}}
  ]
  ```
  """
  @spec leaf_nodes_from_frequencies(map) :: [Tree.tree()]
  def leaf_nodes_from_frequencies(frequency_map) do
    frequency_map
    |> Enum.map(& &1)
    |> Enum.map(fn {k, v} -> Tree.new(%{symbols: k, freq: v}) end)
  end
end
